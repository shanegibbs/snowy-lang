%skeleton "lalr1.cc"
%require  "3.0"
%debug
%defines
%define api.namespace {Snowy}
%define parser_class_name {ProgramParser}
%define parse.error verbose

%code requires { /* code for the defines/header file */
#include <Args.h>
#include <ArgsDecl.h>
#include <Call.h>
#include <DeclareVar.h>
#include <DeclareFunc.h>
#include <Expression.h>
#include <Type.h>
#include <Ident.h>
#include <IntLiteral.h>
#include <Node.h>
#include <Statement.h>
#include <StringLiteral.h>
#include <Tuple.h>
#include <Operator.h>

namespace Snowy {
   class Driver;
}

}

%parse-param { Driver *driver }

%code { /* goes into the impl of Parser */
   #include <string>
   #include <iostream>
   #include <cstdlib>
   #include <fstream>

  /* So we can call Driver functions */
  #include "Driver.h"

  /* because we want the tokens that the parser generates */
  #include "ProgramParser.h"

  /* The parser calls back to the driver using this macro */
  #define yylex driver->mylex
}

/* token types. Also used by the lexer */
%union {
  Snowy::Args *args;
  Snowy::ArgsDecl *args_decl;
  Snowy::Call *call;
  Snowy::DeclareVar *declare_var;
  Snowy::DeclareFunc *declare_func;
  Snowy::Expression *expression;
  Snowy::Type *type;
  Snowy::Ident *ident;
  Snowy::IntLiteral *int_literal;
  Snowy::Node *node;
  Snowy::Operator *oper;
  Snowy::Statement* statement;
  Snowy::StringLiteral* string_literal;
  Snowy::Tuple* tuple;
  char* character;
  string* str;
  int token;
}

%token <str> ID
%token <str> INTEGER
%token <str> STRING_LIT
%token <str> ENDL
%token <token> EQ_OP
%token <str> OP
%token <token> COMMA
%token <token> OPEN_BRACKET
%token <token> CLOSE_BRACKET
%token <token> DO
%token <token> END
%token <token> WHITE_SPACE

%type <node> program
%type <node> block
%type <node> node
%type <type> type
%type <ident> ident
%type <call> call
%type <args> args
%type <args_decl> args_decl
%type <oper> op
%type <expression> expr
%type <declare_var> var_decl
%type <declare_func> func_decl
%type <statement> stmt
%type <tuple> tuple

%left OP
%left UOP

%%

program: program node end { $1->setNext($2); $$ = $2; }
    | node end { driver->setRoot($1); }
    ;

end: {}
    | end ENDL {}
    | ENDL {}
    ;

node: stmt { $$ = $1; }
    | expr { $$ = $1; }
    ;

stmt: var_decl { $$ = $1; }
    | func_decl { $$ = $1; }
    ;

var_decl: type ident EQ_OP expr { $$ = new Snowy::DeclareVar($1, $2, $4); }
    ;

type: ID { $$ = new Snowy::Type($1); }
    ;

ident: ID { $$ = new Snowy::Ident($1); }
    ;

op: OP { $$ = new Snowy::Operator($1); }
    ;

tuple: expr op expr %prec UOP { $$ = new Snowy::Tuple($1, $2, $3); }
    ;

call: ident OPEN_BRACKET args CLOSE_BRACKET { $$ = new Call($1, $3); }
    ;

block: { $$ = NULL; }
    | block node end { $1->setNext($2); $$ = $2; }
    | node end { $$ = $1; }
    ;

func_decl: type ident OPEN_BRACKET args_decl CLOSE_BRACKET DO end block END { $$ = new DeclareFunc($1, $2, $4, $8); }

expr: INTEGER { $$ = new Snowy::IntLiteral($1); }
    | STRING_LIT { $$ = new Snowy::StringLiteral($1); }
    | OPEN_BRACKET tuple CLOSE_BRACKET { $$ = $2; }
    | tuple { $$ = $1; }
    | call { $$ = $1; }
    | ident { $$ = $1; }
    ;

args: { $$ = new Args; } // blank
    | expr { $$ = new Args($1); }
    | args COMMA expr { $1->addArg($3); }
    ;

args_decl: { $$ = new ArgsDecl; } // blank
    | type ident { $$ = new ArgsDecl($1, $2); }
    | args_decl COMMA type ident { $1->addArgDecl($3, $4); }
    ;

%%

void
Snowy::ProgramParser::error( const std::string &err_message )
{
   const char* err = err_message.c_str();
   char* err_cpy = (char*)malloc(strlen(err) + 1);
   strcpy(err_cpy, err);
   driver->error(err_cpy);
}
